= Proyecto _cicd-librerias_

== Resumen

Este proyecto representa un ejemplo y template de una cadena CI/CD contruida con la idea de simplificar el stack
de productos requeridos, su instalación y, sobre todo, la preparación de pipelines y jobs para los circuitos más
habituales.

Esta primera versión se limita a las etapas correspondientes a CI (hasta el deploy a los registries de artefactos e imagenes docker), 
y al gestor de proyectos maven sobre proyectos java/SpringBoot o similares. Partiendo de este template es muy sencillo
agregar las configuraciones correspondientes a otros entornos, tales como node.js, python, JS, Angular, etc.

En versiones posteriores está previsto incluir los jobs correspondientes a CD, concretamente para Terraform,
Helm/Kubernetes y Ansible.
 
== Versiones

[cols=".<1,.<1,.<1,.<6", options="header"]
|===
|Vers
|Por
|Fecha
|Notas

|1.0.0
|FNG
|05/08/2022
|Primera versión CI para maven/java

|===

== 1. Introducción

Los stacks CI/CD más habituales están compuestos de varios productos, especializados cada uno de ellos en un aspecto concreto
de la cadena o pipeline de la solución final. Es muy frecuente encontrar stacks que incluyen 5 o más
productos diferentes: Gitlab, Jenkins, Sonar, Nexus, Vault, Octopus, etc.

Es evidente que instalar (y sobre todo configurar) muchos productos heterogéneos no es un trabajo trivial. Algunos vendors
permiten simplificar esta tarea mediante soluciones previamente integradas (véase el caso de RedHat OpenShift, los servicios
CI/CD de Amazon Web Services, etc.) aunque, lógicamente, no se trata de simples black-boxes, puesto que cada organización
tiene sus propios requisitos de CI/CD. No es lo mismo un pequeño ISV que una gran Entidad Financiera, por lo que siempre es necesario
hacer "retoques" sobre las configuraciones por defecto.

Por otra parte, los coordinadores de circuitos tipo *Jenkins* se configuran mediante un lenguaje de
programación que, aunque sencillo, requiere que los ingenieros de DevOps tengan ciertos conocimientos de
programación y estén familiarizados con el lenguaje en cuestión. Si, además (y es lo habitual) el código debe
mantenerse como read-only para los 'developers', y debe ser modular (empleando
librerías), la curva de aprendizaje suele ser costosa.

En este proyecto se ha intentado minimizar:

- El número de productos implicados.
- La complejidad de la definición de
pipelines, todo ello en en base al empleo de las capacidades CI/CD que Gitlab ofrece en sus últimas versiones.

== 2. Entorno de desarrollo

=== 2.1. Hardware y software de base

- Server
* Máquina virtual en Hyper-V.
* 24 GB Memoria max.
* 4 procesadores virtuales.
* Ubuntu 20.04.1
* Docker 20.10.17

- Workstation
* Core i7-1165G7
* 16 GB memoria
* 512 GB SSD
* Windows 11 Pro
* Visual Studio Code 1.69.2
* Eclipse 2022-06 (4.24.0)

=== 2.2. Productos para CI/CD

Todos los productos se han instalado como imagenes docker, y se lanzan mediante docker-compose.

- Gitlab OMNIBUS 15.2.1-ee.0
- Gitlab-runner: latest
- Sonarqube 9.5.0-community
- PostgreSQL 12.2
- Portainer ce:2.14.1

== 3. Visión general de la solución

=== 3.1 Gitlab como entorno CI/CD

En sus últimas versiones, Gitlab incorpora un conjunto de características que lo hacen un buen
candidato para soportar el grueso de las cadenas CI/CD de manera integrada. Vamos a comentar
algunos de los aspectos principales.

==== 3.1.1 Repositorio de código fuente

Git y Gitlab representan el estándar de-facto para la gestión de código fuente. No vamos a entrar
a explicar este aspecto, por ser sobradamente conocido. Sin embargo, hay características menos conocidas
que conviene mencionar.

- Gitlab incluye un *Issue manager* sencillo pero bastante completo, hasta el punto de que podría
emplearse como sustituto de *Jira*.
- También incluye una *Wiki* con soporte de varios lenguajes de markup que, como en el caso anterior,
podría emplearse como sustituto de *Confluence*.
