= Proyecto _cicd-librerias_
Faustino Nebrera <faustino.nebrera@vass.es>
1.0.0, 07/08/2022
:toc:
:toclevels: 3
:icons: font

== Resumen

Este proyecto representa un ejemplo y template de una cadena CI/CD construida con la idea de simplificar el stack
de productos requeridos, su instalación y, sobre todo, la preparación de pipelines y jobs para los circuitos más
habituales.

icon:warning[2x,role=red] Esta primera versión se limita a las etapas correspondientes a CI (hasta el deploy a los registries de artefactos e imagenes _docker_), 
y al gestor de proyectos maven sobre proyectos java/SpringBoot o similares. Partiendo de este template es muy sencillo
agregar las configuraciones correspondientes a otros entornos, tales como node.js, python, Angular, etc.

icon:calendar[2x,role=yellow] En versiones posteriores está previsto incluir los jobs correspondientes a CD, concretamente para Terraform,
Helm/Kubernetes y Ansible.
 
== Versiones

[cols=".<1,.<1,.<1,.<6", options="header"]
|===
|Vers
|Por
|Fecha
|Notas

|1.0.0
|FNG
|05/08/2022
|Primera versión CI para maven/java

|===

:sectnums:
== Introducción

Los stacks CI/CD más habituales están compuestos de varios productos, especializados cada uno de ellos en un aspecto concreto
de la cadena o pipeline de la solución final. Es muy frecuente encontrar stacks que incluyen 5 o más
productos diferentes: Gitlab, Jenkins, Sonar, Nexus, Vault, Octopus, etc.

Es evidente que instalar (y sobre todo configurar) muchos productos heterogéneos no es un trabajo trivial. Algunos vendors
permiten simplificar esta tarea mediante soluciones previamente integradas (véase el caso de RedHat OpenShift, los servicios
CI/CD de Amazon Web Services, etc.) aunque, lógicamente, no se trata de simples black-boxes, puesto que cada organización
tiene sus propios requisitos de CI/CD. No es lo mismo un pequeño ISV que una gran Entidad Financiera, por lo que siempre es necesario
hacer "retoques" sobre las configuraciones por defecto.

Por otra parte, los coordinadores de circuitos tipo *Jenkins* se configuran mediante un lenguaje de
programación que, aunque sencillo, requiere que los ingenieros de DevOps tengan ciertos conocimientos de
programación y estén familiarizados con el lenguaje en cuestión. Si, además (y es lo habitual) el código debe
mantenerse como read-only para los 'developers', y debe ser modular (empleando
librerías), la curva de aprendizaje suele ser costosa.

En este proyecto se ha intentado minimizar:

- El número de productos implicados.
- La complejidad de la definición de
pipelines, todo ello en en base al empleo de las capacidades CI/CD que Gitlab ofrece en sus últimas versiones.

[sidebar]
.Importante
--
Independientemente de cuál sea su formación previa en CI/CD, la lectura de este documento puede ser útil para afianzar conceptos básicos y entender la filisofía de los pipelines  de CI/CD.
--

== Entorno de desarrollo

=== Hardware y software de base

Server::
* Máquina virtual en Hyper-V.
* 24 GB Memoria max.
* 4 procesadores virtuales.
* Ubuntu 20.04.1
* Docker 20.10.17

Workstation::
* Core i7-1165G7
* 16 GB memoria
* 512 GB SSD
* Windows 11 Pro
* Visual Studio Code 1.69.2
* Eclipse 2022-06 (4.24.0)

=== Productos para CI/CD

Todos los productos se han instalado como imágenes docker, y se lanzan mediante docker-compose.

- Gitlab OMNIBUS 15.2.1-ee.0
- Gitlab-runner: latest
- Sonarqube 9.5.0-community
- PostgreSQL 12.2
- Portainer ce:2.14.1

== Visión general de la solución

=== Gitlab como entorno CI/CD

En sus últimas versiones, Gitlab incorpora un conjunto de características que lo hacen un buen
candidato para soportar el grueso de las cadenas CI/CD de manera integrada. Vamos a comentar
algunos de los aspectos principales.

==== Repositorio de código fuente

Git/Gitlab representan el estándar de-facto para la gestión de código fuente. No vamos a entrar
a explicar git, por ser sobradamente conocido. Sin embargo, hay características menos conocidas
que conviene mencionar.

- Gitlab incluye un *Issue Manager* sencillo pero bastante completo, hasta el punto de que, en algunos casos, podría
emplearse como sustituto de _Jira_(TM).
- También incluye una *Wiki* con soporte de varios lenguajes de markup que, como en el caso anterior,
podría emplearse como sustituto de _Confluence_(TM), al menos en lo que se refiere a documentación de los proyectos.

==== Coordinador CI/CD

Gitlab incluye un coordinador de CI/CD relativamente poco conocido, dado que tradicionalmente sus capacidades han estado por
debajo de los productos más usuales, tales como _Jenkins_(TM) o _TeamCity_(TM). En sus últimas versiones, sin embargo, Gitlab se ha posicionado
como un serio competidor fundamentalmente por las siguientes razones:

* Todo el "plumbing" de CI/CD está estrechamente integrado con el repositorio de código fuente, emplea la misma interfaz de usuario,
y simplifica la eventual integración de otros productos.

* Los _pipelines_ se definen mediante un lenguaje de markup sobradamente conocido (yaml), lo que evita tener que aprender un lenguaje
específico.

* Si se requieren acciones complejas, el entorno de "shell" está directamente integrado con los jobs. Es muy fácil, además,
crear librerías de funciones escritas en .sh, .bash, etc. y llamarlas directamente desde un job. En un entorno complejo,
los ingenieros DevOps peden concentrarse en la creación de pipelines, dejando los detalles de programación del flujo a los desarrolladores.

Más adelante se explica en mayor detalle el modo de trabajar con Gitlab CI/CD.

==== Verificación de Calidad del Código

En este apartado, Gitlab no dispone de una solución propia, sino que
integra el producto CodeClimate. Dado que el estándar de facto para esta fase es _SonarQube_, que además se integra fácilmente con los gestores de proyectos más habituales (maven, gradle, npm..), hemos preperido integrar este producto en el presente ejemplo. Más adelante se explica en detalle este proceso.

==== Tests Unitarios

De nuevo Gitab se apoya en soluciones de terceros tanto para la ejecución de tests unitarios como SAST. En nuestro caso, emplearemos las capacidades embebidas en _maven_, más que suficientes en la mayor parte de los proyectos.

==== Construcción de Artefactos

La mayor parte de los gestores de proyectos (_maven_, _gradle_, _npm_..) disponen de sus propios mecanismos de detección de dependencias y construcción del/los artefactos finales. En este proyecto nos hemos apoyado en las capacidades de maven, como se verá más adelante.
 

